{"version":3,"sources":["webpack:///../src/docs/javascript/basic/基本语法和数据类型.mdx","webpack:///../src/docs/javascript/basic/public/code-block.jpg"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","__list","require","isMDXComponent"],"mappings":"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","file":"component---src-docs-javascript-basic-基本语法和数据类型-mdx-e7a6a1add55fa8c94dfc.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/wuliang/WorkSpace.localized/courses/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nimport { Tabs } from '@/Tabs';\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"基本语法和数据类型\"\n    }}>{`基本语法和数据类型`}</h1>\n\n    <Tabs activeId=\"1\" minHeight=\"180px\" mdxType=\"Tabs\">\n  <Tabs.Tab id=\"1\" title=\"参考资料📖\">{`\n    ${__list([['语法和数据类型', '本章讨论 JavaScript 的基本语法，变量声明，数据类型 和 字面量。', 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_Types', 'From MDN']])}\n    <div class=\"more\"><a href=\"https://juejin.cn/post/6985459853183434789\" target=\"_blank\">👉🏻 更多内容📚</a></div>\n  `}</Tabs.Tab>\n  <Tabs.Tab id=\"2\" title=\"练习题📝\">{__list([['练习', '我们在码上掘金上试试看。', 'https://code.juejin.cn']])}</Tabs.Tab>\n  <Tabs.Tab id=\"3\" title=\"交流讨论🔥\">{__list([['交流讨论', '来沸点交流讨论吧💬', 'https://juejin.cn/pins/club/6824710202655244301']])}</Tabs.Tab>\n    </Tabs>\n    <h2 {...{\n      \"id\": \"基础\"\n    }}>{`基础`}</h2>\n    <p>{`JavaScript 借鉴了 Java 的大部分语法，但同时也受到 Awk，Perl 和 Python的影响。 `}</p>\n    <p>{`JavaScript代码由符号（Tokens）组成语句（Statements）和语句块（Blocks），然后由语句和语句块组成程序（Program）。`}</p>\n    <p>{`对于JavaScript语言，符号是`}<strong parentName=\"p\">{`词法`}</strong>{`基本单元，而语句是`}<strong parentName=\"p\">{`语法`}</strong>{`基本单元。JavaScript通过一条语句来执行某个指令或者计算某个表达式的值。`}</p>\n    <h2 {...{\n      \"id\": \"语句块block\"\n    }}>{`语句块（Block）`}</h2>\n    <p>{`语句由一个或多个Token构成，通常以分号`}<inlineCode parentName=\"p\">{`;`}</inlineCode>{`结尾。语句块由一条或多条语句构成，通常以右花括号`}<inlineCode parentName=\"p\">{`}`}</inlineCode>{`结尾。`}</p>\n    <p>{`尽管在JavaScript中，我们随时可以单独使用一对花括号`}<inlineCode parentName=\"p\">{`{`}</inlineCode>{`和`}<inlineCode parentName=\"p\">{`}`}</inlineCode>{`构造一块语句块，但我们`}<strong parentName=\"p\">{`一般很少这样做`}</strong>{`。`}</p>\n    <p><img alt=\"\\u72EC\\u7ACB\\u8BED\\u53E5\\u5757\" src={require(\"./public/code-block.jpg\")} /></p>\n    <p>{`在上面的例子里，我们使用花括号构建了一个语句块，在JavaScript中，语句块构成一个`}<strong parentName=\"p\">{`块级作用域`}</strong>{`，关于这个概念，我们将在后续章节中详细说明。现在我们只要简单理解，在语句块中可以再次声明一个语句块之外存在的变量，如果我们这么做了，我们可以在语句块中访问到的是语句块内部的变量，在语句块外访问到的是语句块外部的变量。`}</p>\n    <p>{`我们一般不刻意单独使用语句块，而是在一些`}<strong parentName=\"p\">{`复合语句`}</strong>{`中，语句块作为其中的部分结构出现，我们后面会详细讨论，先试举一二例子：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`do {\n  if(subject.tagName === 'SECTION') {\n    break;\n  }\n  subject = subject.parentElement;\n} while(subject);\n`}</code></pre>\n    <p>{`上面的`}<inlineCode parentName=\"p\">{`do...while`}</inlineCode>{`是一条`}<strong parentName=\"p\">{`循环语句`}</strong>{`，其中`}<inlineCode parentName=\"p\">{`do`}</inlineCode>{`执行的部分是一个语句块，do中的`}<inlineCode parentName=\"p\">{`if`}</inlineCode>{`语句是`}<strong parentName=\"p\">{`条件分支语句`}</strong>{`，它的`}<strong parentName=\"p\">{`条件表达式`}</strong>{`后面跟着的也是一个语句块，尽管其中只有`}<inlineCode parentName=\"p\">{`break;`}</inlineCode>{`一条语句。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const add = function(x, y) {\n  return x + y;\n};\n`}</code></pre>\n    <p>{`上面的`}<inlineCode parentName=\"p\">{`const add = function...`}</inlineCode>{`是一个变量声明和初始化语句，它将一个函数表达式的值赋给变量add，函数表达式本身的函数体部分也是一个语句块。`}</p>\n    <p>{`从上面的例子我们看到，`}<strong parentName=\"p\">{`JavaScript的一些语句可以包含语句块，语句块中再包含语句，层层嵌套，构成JavaScript程序结构`}</strong>{`。`}</p>\n    <p>{`为了表述方便，今后我们将语句和语句块统称为`}<strong parentName=\"p\">{`语句`}</strong>{`。我们将JavaScript的语句分为空语句、变量语句、函数声明语句、表达式语句、条件语句、循环语句、跳转语句、异常处理语句和其他语句，我们接下来将一一介绍它们。`}</p>\n    <h2 {...{\n      \"id\": \"空语句\"\n    }}>{`空语句`}</h2>\n    <p>{`顾名思义，`}<strong parentName=\"p\">{`空语句`}</strong>{`是不包含任何执行动作的语句，它只由一个分号Token构成。JavaScript解析器执行到空语句时不会执行任何动作。`}<strong parentName=\"p\">{`空语句`}</strong>{`一般不单独使用，而是与其他语句一同构成，比如在if语句或for语句中表示空的动作或条件。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`if(a > 0 && b < 1.5);\nelse {\n  ...\n}\n`}</code></pre>\n    <p>{`上面的if语句，当条件满足`}<inlineCode parentName=\"p\">{`a > 0`}</inlineCode>{`且`}<inlineCode parentName=\"p\">{`b < 1.5`}</inlineCode>{`的时候，不执行任何动作，其他情况下执行`}<inlineCode parentName=\"p\">{`else`}</inlineCode>{`条件。这时候我们使用空语句表示满足if条件时不执行任何动作。`}</p>\n    <p>{`同样，我们可以省略`}<inlineCode parentName=\"p\">{`for`}</inlineCode>{`循环体：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const arr = new Array(5);\n\nfor(let i = 0; i < arr.length; arr[i] = ++i);\n\nconsole.log(arr); // [1, 2, 3, 4, 5]\n`}</code></pre>\n    <p>{`实际上，上面两种情况不是很好的用法，因为if和for的右括号后面的分号很不起眼，这样容易造成一些bug。如果一定要这么用，建议加上注释：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const arr = new Array(5);\n\nfor(let i = 0; i < arr.length; arr[i] = ++i) /*do nothing*/;\n\nconsole.log(arr); // [1, 2, 3, 4, 5]\n`}</code></pre>\n    <p>{`如果从代码清晰易懂的角度来讲，上面的写法都不必要，可以改成：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`if(a <= 0 || b >= 1.5){\n  ...\n}\n\nconst arr = new Array(5);\n\nfor(let i = 0; i < arr.length; ++i) {\n  arr[i] = i + 1;\n}\n\nconsole.log(arr); // [1, 2, 3, 4, 5]\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"声明语句\"\n    }}>{`声明语句`}</h2>\n    <p>{`与其他大多数编程语言一样，JavaScript的变量要`}<strong parentName=\"p\">{`先声明再使用`}</strong>{`。声明变量的语句是JavaScript的`}<strong parentName=\"p\">{`声明语句`}</strong>{`。`}</p>\n    <p>{`JavaScript有三种声明变量的方式，分别是`}<inlineCode parentName=\"p\">{`let`}</inlineCode>{`、`}<inlineCode parentName=\"p\">{`var`}</inlineCode>{` 和 `}<inlineCode parentName=\"p\">{`const`}</inlineCode>{`，下面我们一一说明。`}</p>\n    <h3 {...{\n      \"id\": \"let声明变量\"\n    }}><inlineCode parentName=\"h3\">{`let`}</inlineCode>{`声明变量`}</h3>\n    <p><inlineCode parentName=\"p\">{`let`}</inlineCode>{`声明变量的基本格式为：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`let 变量名;\n`}</code></pre>\n    <p>{`JavaScript在变量声明的同时还可以进行初始化，`}<inlineCode parentName=\"p\">{`let`}</inlineCode>{`变量声明并初始化的基本格式为：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`let 变量名 = 值;\n`}</code></pre>\n    <p>{`我们可以通过逗号`}<inlineCode parentName=\"p\">{`,`}</inlineCode>{`同时声明多个变量：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`let a, b = 0, c, d = 1;\n`}</code></pre>\n    <p>{`变量如果只声明不初始化，那么该变量的初始值为`}<inlineCode parentName=\"p\">{`undefined`}</inlineCode>{`。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`let a, b = 0, c, d = 1;\n\nconsole.log(a, b, c, d); // undefined, 0, undefined, 1\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"作用域\"\n    }}>{`作用域`}</h3>\n    <p>{`“作用域(scope)”是程序设计的一个重要概念，它是指变量（或函数）声明后可以被访问的代码范围。在单一文件里，let声明的变量只在它所在的块（blocks）中有效，如果let声明在任何block之外，那么该let声明的变量在它声明之后直到文件末尾都有效。我们前面已经见过这样的例子：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`let foo = 'foo';\nlet bar = 'outer bar';\n{\n  let bar = 'inner bar';\n  console.log(foo, bar);  // foo inner bar\n}\nconsole.log(foo, bar);  // foo outer bar\n`}</code></pre>\n    <p>{`上面的例子，block中重新声明bar会覆盖外层的bar,因此在block内部访问到的bar是内层的`}<inlineCode parentName=\"p\">{`inner bar`}</inlineCode>{`，在block外访问到的则是外层的`}<inlineCode parentName=\"p\">{`outer bar`}</inlineCode>{`。因为foo只声明在外层，block内没有声明，所以在块内块外访问foo，得到的都是外层的foo。`}</p>\n    <p>{`如果我们只在block内声明一个变量，而在block外尝试访问它，那么解释器会抛出变量不存在的异常：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`let foo = 'foo';\n{\n  let bar = 'inner bar';\n  console.log(foo, bar); // foo inner bar\n}\nconsole.log(foo, bar); // Uncaught ReferenceError: bar is not defined\n`}</code></pre>\n    <p>{`block作用域适用于任何可以出现在语句块的地方，例如if语句、while语句、函数体、try...catch等等，另外for语句的条件中以`}<inlineCode parentName=\"p\">{`let`}</inlineCode>{`声明变量，变量的作用域也被限制在for语句的语句块中。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`let a = 10;\nif(a > 0) {\n  let a = 20;\n  console.log(a); // 20\n}\nconsole.log(a); // 10\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`let i =  100;\nfor(let i = 0; i < 5; i++) {\n  console.log(i); // 0 1 2 3 4 \n}\nconsole.log(i); // 100\n`}</code></pre>\n    <p>{`我们必须在`}<inlineCode parentName=\"p\">{`let`}</inlineCode>{`声明之后才能使用变量，如果我们在声明之前使用它，解释器会抛出异常。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`console.log(a); // Uncaught ReferenceError: a is not defined\nlet a = 10;\nconsole.log(a);\n`}</code></pre>\n    <p>{`这里还有一点需要注意，虽然我们在block内部可以访问block外部声明的变量，但当我们在block内以`}<inlineCode parentName=\"p\">{`let`}</inlineCode>{`声明一个变量时，不管它出现在什么位置，我们在整个block内的任何位置都不能再访问和这个同名的外部变量：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`let foo = 'foo';\nlet bar = 'outer bar';\n\n{\n  console.log(foo); // foo\n  console.log(bar); // Uncaught ReferenceError: bar is not defined\n  let bar = 'inner bar';\n  console.log(foo);\n  console.log(bar);\n}\nconsole.log(foo);\nconsole.log(bar);\n`}</code></pre>\n    <p>{`上面的例子里，程序在第一个`}<inlineCode parentName=\"p\">{`console.log(bar)`}</inlineCode>{`那里就会抛出异常，因为block内以`}<inlineCode parentName=\"p\">{`let`}</inlineCode>{`方式声明了bar，而`}<inlineCode parentName=\"p\">{`console.log(bar)`}</inlineCode>{`在`}<inlineCode parentName=\"p\">{`let`}</inlineCode>{`声明之前就访问了bar。尽管外部还有声明bar，但是这里仍然会抛出异常，而不能访问到外部的bar的值。访问`}<inlineCode parentName=\"p\">{`console.log(foo)`}</inlineCode>{`则没有问题，因为在block内部没有声明foo，它访问到的是正常的外部的foo。`}</p>\n    <p>{`这种情况，相当于在block内部从左花括号`}<inlineCode parentName=\"p\">{`{`}</inlineCode>{`开始直到`}<inlineCode parentName=\"p\">{`let bar`}</inlineCode>{`语句这条语句之间的这个区域都不能访问bar这个变量，这个区间被称为变量bar的`}<strong parentName=\"p\">{`暂时死区`}</strong>{`(Temporal Dead Zone简称`}<inlineCode parentName=\"p\">{`TDZ`}</inlineCode>{`)。用let声明变量总会导致TDZ，范围从作用域开始位置到let声明位置之间，在这个位置中间无论外层有没有声明同名变量，该变量都不能被访问。`}</p>\n    <h3 {...{\n      \"id\": \"var声明变量\"\n    }}><inlineCode parentName=\"h3\">{`var`}</inlineCode>{`声明变量`}</h3>\n    <p><inlineCode parentName=\"p\">{`var`}</inlineCode>{`声明变量的基本格式为：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`var 变量名;\n`}</code></pre>\n    <p>{`与`}<inlineCode parentName=\"p\">{`let`}</inlineCode>{`声明一样，变量可以在声明的同时进行初始化：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`var 变量名 = 值;\n`}</code></pre>\n    <p>{`我们也一样可以通过逗号`}<inlineCode parentName=\"p\">{`,`}</inlineCode>{`同时声明多个变量，未初始化变量的值也是`}<inlineCode parentName=\"p\">{`undefined`}</inlineCode>{`。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`var a, b = 1, c = 2, d;\n\nconsole.log(a, b, c, d); // undefined 1 2 undefined\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`var`}</inlineCode>{`是JavaScript早期的变量声明方式，在ES5之前，我们只能使用`}<inlineCode parentName=\"p\">{`var`}</inlineCode>{`声明变量。`}<inlineCode parentName=\"p\">{`var`}</inlineCode>{`与`}<inlineCode parentName=\"p\">{`let`}</inlineCode>{`声明有许多不同之处。首先`}<inlineCode parentName=\"p\">{`var`}</inlineCode>{`没有块级作用域，如果同时在块内和外层声明同名的变量，实际上变量只会被声明一次。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`var foo = 'foo',\n  bar = 'outer bar';\n{\n  var bar = 'inner bar';\n  console.log(foo, bar); // foo inner bar\n}\nconsole.log(foo, bar); // foo inner bar\n`}</code></pre>\n    <p>{`上面的代码，实际上相当于：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`var foo = 'foo',\n  bar = 'outer bar';\n{\n  bar = 'inner bar';\n  console.log(foo, bar);\n}\nconsole.log(foo, bar);\n`}</code></pre>\n    <p>{`同样，在循环语句中声明的变量，作用域会覆盖到循环语句外：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`for(var i = 0; i < 5; i++) {\n  console.log(i); // 0 1 2 3 4\n}\nconsole.log(i); // 5\n`}</code></pre>\n    <p>{`上面的代码相当于：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`var i;\nfor(i = 0; i < 5; i++) {\n  console.log(i);\n}\nconsole.log(i);\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`var`}</inlineCode>{`声明的变量虽然没有块级作用域，但是JavaScript函数体有作用域，因此我们可以使用立即调用函数(IIFE)来为var声明的变量构造作用域。关于立即调用函数(IIFE)在这里可以不必深究，在后续课程中我们还会有进一步的介绍。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`var foo = 'foo',\n  bar = 'outer bar';\n(function() {\n  var bar = 'inner bar';\n  console.log(foo, bar); // foo inner bar\n}());\nconsole.log(foo, bar); // foo outer bar\n`}</code></pre>\n    <p>{`与`}<inlineCode parentName=\"p\">{`let`}</inlineCode>{`会造成TDZ不同，`}<inlineCode parentName=\"p\">{`var`}</inlineCode>{`声明的变量不论在什么位置，声明都会被提升（hoist）到函数作用域的最开始处，如果`}<inlineCode parentName=\"p\">{`var`}</inlineCode>{`不在任何函数内部而在最外层，那么声明会被提升到文件开头。因此，在初始化之前的任何位置调用`}<inlineCode parentName=\"p\">{`var`}</inlineCode>{`声明的变量，都不会抛出异常，而是返回变量初始值undefined：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`var foo = 'foo';\nvar bar = 'outer bar';\n\n(function(){\n  console.log(foo); // foo\n  console.log(bar); // undefined\n  var bar = 'inner bar';\n  console.log(foo); // foo\n  console.log(bar); // inner bar\n}());\nconsole.log(foo); // foo\nconsole.log(bar); // outer bar\n`}</code></pre>\n    <p>{`上面的例子里，在IIFE函数中第一次访问变量bar时，因为它还未初始化，所以bar的值是undefined。上面的代码中，\b内层的bar声明被提升到函数作用域的最开始处，相当于：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`var foo = 'foo';\nvar bar = 'outer bar';\n\n(function(){\n  var bar;\n  console.log(foo); // foo\n  console.log(bar); // undefined\n  bar = 'inner bar';\n  console.log(foo); // foo\n  console.log(bar); // inner bar\n}());\nconsole.log(foo); // foo\nconsole.log(bar); // outer bar\n`}</code></pre>\n    <p>{`另外，浏览器的JavaScript里，当`}<inlineCode parentName=\"p\">{`let`}</inlineCode>{`和`}<inlineCode parentName=\"p\">{`var`}</inlineCode>{`声明出现在最外层时，`}<inlineCode parentName=\"p\">{`var`}</inlineCode>{`声明的变量可以通过浏览器window对象的属性访问，而let声明的变量则不可以：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`var a = 10;\nconsole.log(a, window.a); // 10 10\n\nlet b = 20;\nconsole.log(b, window.b); // 20 undefined\n`}</code></pre>\n    <p>{`而注意，在Node.js里，不论是`}<inlineCode parentName=\"p\">{`let`}</inlineCode>{`还是`}<inlineCode parentName=\"p\">{`var`}</inlineCode>{`声明的最外层变量，都不能通过global对象的属性访问到。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`var a = 10;\nconsole.log(a, global.a); // 10 undefined\n\nlet b = 20;\nconsole.log(b, global.b); // 20 undefined\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"不声明直接使用变量\"\n    }}>{`不声明直接使用变量`}</h3>\n    <p>{`前面我们说过，在非严格模式下，如果不声明直接使用变量，那么变量会被视为全局变量，在浏览器下可以通过window属性访问到，在Node.js下可以通过global访问到。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`a = 10;\nconsole.log(window.a); // 10，在Node.js下global.a也是10\n`}</code></pre>\n    <p>{`在严格模式下，不声明直接使用变量会抛出异常。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`'use strict';\na = 10;\nconsole.log(window.a); // Uncaught ReferenceError: a is not defined\n`}</code></pre>\n    <p>{`虽然说非严格模式并不禁止不声明直接使用变量，但这是一种非常不好的习惯，应当要禁止。无论任何时候，我们使用变量的时候，都应该要先声明再使用。当我们配置了eslint时，只要我们无意中忘记声明而直接使用了变量，eslint就会给出提示。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`for(i = 0; i < 5; i++) { // 这里忘记了对i进行声明，eslint会给出错误信息提示\n\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"const声明变量\"\n    }}><inlineCode parentName=\"h3\">{`const`}</inlineCode>{`声明变量`}</h3>\n    <p><inlineCode parentName=\"p\">{`const`}</inlineCode>{`是英文单词constant的简称，表示“常量”的意思。`}<inlineCode parentName=\"p\">{`const`}</inlineCode>{`的使用方式和`}<inlineCode parentName=\"p\">{`let`}</inlineCode>{`几乎完全一样。区别在于，使用`}<inlineCode parentName=\"p\">{`const`}</inlineCode>{`声明的变量不能只声明不初始化，而必须在声明的时候初始化，而且一旦初始化了，在之后的代码中不能对它重新赋值。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const foo = 'foo';\nfoo = 'bar'; // Uncaught TypeError: Assignment to constant variable.\n`}</code></pre>\n    <p>{`上面的代码中，我们尝试对foo重新赋值，解释器会抛出异常。需要注意的是，虽然`}<inlineCode parentName=\"p\">{`const`}</inlineCode>{`声明禁止对变量重新赋值，但是它并不禁止修改非基本数据类型变量的属性值：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const foo = {x: 1};\nfoo.x = 2;\nconsole.log(foo); // {x: 2}\nfoo = 'bar'; // Uncaught TypeError: Assignment to constant variable.\n`}</code></pre>\n    <p>{`上面的代码，`}<inlineCode parentName=\"p\">{`const foo`}</inlineCode>{`声明允许修改foo的属性值，因此`}<inlineCode parentName=\"p\">{`foo.x = 2`}</inlineCode>{`是可以正常运行的，但是不能对`}<inlineCode parentName=\"p\">{`foo`}</inlineCode>{`本身进行赋值，所以`}<inlineCode parentName=\"p\">{`foo = 'bar'`}</inlineCode>{`是被禁止的。`}</p>\n    <p>{`与`}<inlineCode parentName=\"p\">{`let`}</inlineCode>{`一样，`}<inlineCode parentName=\"p\">{`const`}</inlineCode>{`也同样有块级作用域和`}<inlineCode parentName=\"p\">{`TDZ`}</inlineCode>{`。`}</p>\n    <h2 {...{\n      \"id\": \"数据类型\"\n    }}>{`数据类型`}</h2>\n    <p>{`最新的 ECMAScript 标准定义了 8 种数据类型，分别是：`}</p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`七种基本数据类型（Primitive Types）`}</p>\n        <ul parentName=\"li\">\n          <li parentName=\"ul\">{`undefined - 变量未赋值时的默认值，表示一个`}<inlineCode parentName=\"li\">{`未定义`}</inlineCode>{`的数据。`}</li>\n          <li parentName=\"ul\">{`null - 表示变量未绑定具体变量的一个特殊值，通常用来作为对象类型的数据未被指定具体值时的初始值。`}</li>\n          <li parentName=\"ul\">{`布尔值（Boolean) - 包含`}<inlineCode parentName=\"li\">{`true`}</inlineCode>{`和`}<inlineCode parentName=\"li\">{`false`}</inlineCode>{`两个字面量，表示逻辑`}<inlineCode parentName=\"li\">{`真`}</inlineCode>{`与`}<inlineCode parentName=\"li\">{`假`}</inlineCode>{`。`}</li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"/courses/js/basic/number\"\n            }}>{`数值（Number）`}</a>{` - 表示整数或浮点数。`}</li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"/courses/js/basic/bigint\"\n            }}>{`大整数（BigInt）`}</a>{` - 表示任意精度的整数。`}</li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"js/basic/string\"\n            }}>{`字符串（String）`}</a>{` - 表示文本的数据类型。`}</li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"js/basic/symbol\"\n            }}>{`Symbol`}</a>{` - 一种实例是唯一且不可改变的数据类型。`}</li>\n        </ul>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`对象类型（Object)`}</p>\n        <p parentName=\"li\">{`对象分为普通`}<a parentName=\"p\" {...{\n            \"href\": \"/courses/js/basic/object\"\n          }}>{`对象（Object）`}</a>{`和可调用对象（Callable Object)，可调用对象即`}<a parentName=\"p\" {...{\n            \"href\": \"/courses/js/basic/function\"\n          }}>{`函数（function)`}</a>{`。`}</p>\n        <p parentName=\"li\">{`基本数据类型、对象（Objects）和函数（functions）是JavaScript的基本元素。基本数据类型用来表示不同类型的值，对象可以看做存放值的一个命名容器，函数是你的程序能够执行的步骤。`}</p>\n      </li>\n    </ul>\n    <h2 {...{\n      \"id\": \"类型检查\"\n    }}>{`类型检查`}</h2>\n    <p>{`JavaScript是一种动态类型的语言，运行时任意标识符可以赋值任意类型的数据，在运行过程中也能够随时改变绑定的数据类型。JavaScript提供了在运行时判断类型的运算符`}<inlineCode parentName=\"p\">{`typeof`}</inlineCode>{`，它能够返回对应的数据类型的字符串描述。对于除了`}<inlineCode parentName=\"p\">{`null`}</inlineCode>{`以外的6种基本数据类型的数据，`}<inlineCode parentName=\"p\">{`typeof`}</inlineCode>{`分别返回`}<inlineCode parentName=\"p\">{`'undefined','boolean','number','bigint','string'`}</inlineCode>{`和`}<inlineCode parentName=\"p\">{`'symbol'`}</inlineCode>{`，而由于历史原因，`}<inlineCode parentName=\"p\">{`typeof null`}</inlineCode>{`返回`}<inlineCode parentName=\"p\">{`'object'`}</inlineCode>{`。对于非基本数据类型的数据，`}<inlineCode parentName=\"p\">{`Object`}</inlineCode>{`类型的`}<inlineCode parentName=\"p\">{`typeof`}</inlineCode>{`结果也为`}<inlineCode parentName=\"p\">{`'object'`}</inlineCode>{`，Function类型的`}<inlineCode parentName=\"p\">{`typeof`}</inlineCode>{`结果为`}<inlineCode parentName=\"p\">{`'function'`}</inlineCode>{`。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`console.log(\n  typeof null,        // object\n  typeof undefined,   // undefined\n  typeof true,        // boolean\n  typeof 123,         // number\n  typeof 123n,        // bigint\n  typeof 'abc',       // string\n  typeof Symbol(),    // symbol\n    typeof Object(),    // object\n  typeof (()=>{}),      // function\n); \n\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"类型转换\"\n    }}>{`类型转换`}</h2>\n    <p>{`JavaScript是弱类型语言，它容忍隐式类型转换，比如前面说过的在布尔判断时可以将其他值转为Boolean类型。同样的，其他的数据类型在一些条件下也可以自动转换。`}</p>\n    <h3 {...{\n      \"id\": \"运算的隐式类型转换规则\"\n    }}>{`运算的隐式类型转换规则`}</h3>\n    <p>{`JavaScript的隐式数据类型转换标准比较复杂，在这里我们仅介绍几个最常见的隐式转换。完整的规则参考`}<a parentName=\"p\" {...{\n        \"href\": \"https://www.ecma-international.org/ecma-262/#sec-type-conversion\"\n      }}>{`ECMA-262`}</a>{`标准文档。`}</p>\n    <p>{`字符串与数值进行相加时，数值被转转换为字符串：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const a = 10, b = 'abc', c = 1;\n\nconsole.log(a + b + c); // 10abc1\n`}</code></pre>\n    <p>{`字符串参与非加法数学运算时，字符串被转换为数值再进行运算：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const a = 123, b = '456', c = 1\n\nconsole.log(a + b - c); //123455\n`}</code></pre>\n    <p>{`如果字符串不是合法的数值格式（合法的数值格式包括十进制整数、浮点数、二进制、八进制、十六进制数和科学记数法以及+Infinity、-Infinity），那么运算的结果为NaN：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const a = 123, b = 'abc', c = 1;\n\nconsole.log(a + b - c); // NaN\n`}</code></pre>\n    <p>{`布尔值与数值进行运算时，`}<inlineCode parentName=\"p\">{`true`}</inlineCode>{`视为1，`}<inlineCode parentName=\"p\">{`false`}</inlineCode>{`视为0，结果为数值：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const a = true, b = false;\n\nconsole.log(a + 1, b * 3); // 2 0\n`}</code></pre>\n    <p>{`布尔值与字符串进行相加时，`}<inlineCode parentName=\"p\">{`true`}</inlineCode>{`转换为字符串'true'，`}<inlineCode parentName=\"p\">{`false`}</inlineCode>{`转换为字符串'false'：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const a = true, b = false;\n\nconsole.log(a + '', b + 'foobar') // 'true' 'falsefoobar'\n`}</code></pre>\n    <h4 {...{\n      \"id\": \"与\"\n    }}>{`==与===`}</h4>\n    <p>{`JavaScript在对两个数进行`}<inlineCode parentName=\"p\">{`==`}</inlineCode>{`比较时，会对两个数进行隐式类型转换，规则如下。`}</p>\n    <p>{`对`}<inlineCode parentName=\"p\">{`x==y`}</inlineCode>{`，如果：`}</p>\n    <ol>\n      <li parentName=\"ol\">{`如果x和y是类型相同的基本数据类型，对它们的值进行比较`}</li>\n      <li parentName=\"ol\">{`如果x和y是Object类型，如果它们引用同样的对象，返回true`}</li>\n      <li parentName=\"ol\">{`如果x是null或undefined，y也是null或undefined，返回true`}</li>\n      <li parentName=\"ol\">{`x的类型是Number，y的类型是String，那么将y转换为Number进行比较`}</li>\n      <li parentName=\"ol\">{`x的类型是String，y的类型是Number，那么将x转换为Number进行比较`}</li>\n      <li parentName=\"ol\">{`x的类型是Boolean，那么先将x转为Number，再照规则4、5进行比较`}</li>\n      <li parentName=\"ol\">{`y的类型是Boolean，那么先将y转为Number，再照规则4、5进行比较`}</li>\n      <li parentName=\"ol\">{`如果x的类型是String、Number或Symbol，y的类型是非基本数据类型，那么先将y转为基本数据类型之后再比较。`}</li>\n      <li parentName=\"ol\">{`如果y的类型是String、Number或Symbol，x的类型是非基本数据类型，那么先将x转为基本数据类型之后再比较。`}</li>\n      <li parentName=\"ol\">{`其他情况返回 false`}</li>\n    </ol>\n    <p>{`举几个例子：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`console.log(100 == '1e2'); // true\nconsole.log(true == '1', false == 0); // true true\n\nlet foo, bar = null;\nconsole.log(foo == null, bar == null,\n    foo == undefined, bar == undefined); // true true true true \n`}</code></pre>\n    <p>{`由于`}<inlineCode parentName=\"p\">{`==`}</inlineCode>{`会做隐式类型转换，在一些情况下可能造成不可预料的结果，所以一般来说，我们推荐尽量使用`}<inlineCode parentName=\"p\">{`===`}</inlineCode>{`来进行比较，后者不会做隐式类型转换，更加安全。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`console.log(true == 1, true === 1); // true false\n`}</code></pre>\n    <p>{`但是我们在通常情况下不区分null还是undefined，因此在判断null的时候仍然可以使用`}<inlineCode parentName=\"p\">{`==`}</inlineCode>{`。`}</p>\n    <h3 {...{\n      \"id\": \"显式类型转换\"\n    }}>{`显式类型转换`}</h3>\n    <p>{`当我们使用了`}<inlineCode parentName=\"p\">{`===`}</inlineCode>{`进行比较之后，两个不同类型的值比较的结果总是`}<inlineCode parentName=\"p\">{`false`}</inlineCode>{`。有时候我们确实要进行类型转换再比较，这时可以使用显式类型转换。`}</p>\n    <p>{`通过调用方法`}<inlineCode parentName=\"p\">{`Number`}</inlineCode>{`、`}<inlineCode parentName=\"p\">{`String`}</inlineCode>{`、`}<inlineCode parentName=\"p\">{`Boolean`}</inlineCode>{`可以将值显式转换类型。`}</p>\n    <p>{`例如：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`console.log(Number('123') === 123); // true\nconsole.log(String(0xf) === '15'); // true\nconsole.log(Boolean(null) === false); // true\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"值和引用\"\n    }}>{`值和引用`}</h2>\n    <p>{`JavaScript的基本数据类型和Object的一个重要区别是基本数据类型是`}<strong parentName=\"p\">{`值类型`}</strong>{`，而Object类型是`}<strong parentName=\"p\">{`引用类型`}</strong>{`。具体而言，就是当给一个标识符赋予值类型的数据时，可以理解为这个标识符绑定的内容是该数据类型的一个“值“，而当给一个标识符赋予一个引用类型的数据时，这个标识符绑定的内容是指向该数据类型真实值的“引用”，（即：内存地址）。我们举例看二者区别：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`let a = 10;\nlet b = a;\n\na = a + 1;\nconsole.log(a, b); // 11, 10\n`}</code></pre>\n    <p>{`上面的例子，a绑定“值“10，`}<inlineCode parentName=\"p\">{`b = a`}</inlineCode>{`让b的值绑定和a同样的值，即b的值也是10。当我们让`}<inlineCode parentName=\"p\">{`a = a + 1`}</inlineCode>{`时，a的值变成11，而b的值仍然是10，这是因为a、b两个变量绑定的是两个不同的数据，虽然它们一开始的值相等，但是我们改变一个，另一个不会跟着改变。`}</p>\n    <p>{`我们再看引用的例子：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`let a = { x: 10 };\nlet b = a;\n\na.x = a.x + 1;\n\nconsole.log(a.x, b.x); // 11, 11\n`}</code></pre>\n    <p>{`上面的例子，a绑定对象`}<inlineCode parentName=\"p\">{`{x: 10}`}</inlineCode>{`，`}<inlineCode parentName=\"p\">{`b = a`}</inlineCode>{`让b绑定和a同样的引用，也就是说此时a、b实际上指向同一个对象，a.x也是b.x，所以当a.x的值改变的时候，b.x的值也随之改变。JavaScript的规范这样规定：`}<strong parentName=\"p\">{`绑定原始对象的值，绑定非原始对象的引用`}</strong>{`。`}</p>\n    <p>{`同样，我们再举一个例子：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`function inc(x) {\n    return x + 1;\n}\n\nfunction incKey(obj, key) {\n    obj[key] += 1;\n}\n\nconst a = 1, b = {x: 1};\n\nconst c = inc(a);\n\nconsole.log(a, b, c); // 1 {x: 1} 2\n\nincKey(b, 'x');\n\nconsole.log(b.x); // 2\n`}</code></pre>\n    <p>{`在上面的例子里，传给`}<inlineCode parentName=\"p\">{`inc(x)`}</inlineCode>{`的是数值，是值类型，所以`}<inlineCode parentName=\"p\">{`inc(a)`}</inlineCode>{`的操作并不会改变实际的a的值，而`}<inlineCode parentName=\"p\">{`incKey(b)`}</inlineCode>{`传的是引用，所以`}<inlineCode parentName=\"p\">{`obj[key] += 1`}</inlineCode>{`改变了b.x的值。`}</p>\n    <p>{`根据上面的例子可以看出，值和引用在实际操作过程中有明显的区别，学习JavaScript应当理解它们的差异。`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","module.exports = __webpack_public_path__ + \"static/code-block-98d223247a4a1850cebb190820db7f84.jpg\";"],"sourceRoot":""}